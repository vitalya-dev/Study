1
00:00:00,860 --> 00:00:03,600
hello whilst recently on my holidays I

2
00:00:03,600 --> 00:00:05,490
met a strange man and he told me I had

3
00:00:05,490 --> 00:00:07,470
two minutes to create a maze that would

4
00:00:07,470 --> 00:00:09,440
take him longer than one minute to solve

5
00:00:09,440 --> 00:00:20,310
so I did this and said solve that there

6
00:00:20,310 --> 00:00:21,449
you go and if you haven't guessed

7
00:00:21,449 --> 00:00:23,880
already this video is about mazes but

8
00:00:23,880 --> 00:00:25,680
more specifically it's about algorithms

9
00:00:25,680 --> 00:00:27,000
and this is an algorithm that I have

10
00:00:27,000 --> 00:00:28,890
loved since I was a child I first

11
00:00:28,890 --> 00:00:30,449
encountered it in the BBC micro

12
00:00:30,449 --> 00:00:32,130
magazines where you have to type in the

13
00:00:32,130 --> 00:00:34,020
programs you sell from acres and acres

14
00:00:34,020 --> 00:00:36,270
of soft listing rarely did the programs

15
00:00:36,270 --> 00:00:38,129
actually work but this one always stuck

16
00:00:38,129 --> 00:00:39,329
with me because it's a fantastic

17
00:00:39,329 --> 00:00:41,190
algorithm and it's perfect and it's

18
00:00:41,190 --> 00:00:42,629
complete and we'll look at the details

19
00:00:42,629 --> 00:00:44,280
of it later and I think it's a great

20
00:00:44,280 --> 00:00:45,840
example of programming and computer

21
00:00:45,840 --> 00:00:48,629
science at its absolute best in just in

22
00:00:48,629 --> 00:00:50,550
case you're wondering today I am living

23
00:00:50,550 --> 00:00:52,140
proof that programmers and code is

24
00:00:52,140 --> 00:00:55,620
actually go outside so there we go now

25
00:00:55,620 --> 00:00:57,180
before we get stuck into the code I'm

26
00:00:57,180 --> 00:00:59,100
just going to provide a quick primer for

27
00:00:59,100 --> 00:01:01,020
the uninitiated and that is what is a

28
00:01:01,020 --> 00:01:02,910
stack because this is fundamentally a

29
00:01:02,910 --> 00:01:05,909
stack based algorithm and a stack can

30
00:01:05,909 --> 00:01:10,979
also be known as a LIFO which stands for

31
00:01:10,979 --> 00:01:18,720
last in first out some people may also

32
00:01:18,720 --> 00:01:22,740
call it a Philo it's the same thing and

33
00:01:22,740 --> 00:01:25,229
the idea is I wanted to imagine a box

34
00:01:25,229 --> 00:01:28,049
like this and if we put some data into

35
00:01:28,049 --> 00:01:31,920
this box it sits at the bottom and then

36
00:01:31,920 --> 00:01:34,290
if we put in some more data into the box

37
00:01:34,290 --> 00:01:37,890
it sits on top but we can't access this

38
00:01:37,890 --> 00:01:39,720
data at the bottom anymore we can only

39
00:01:39,720 --> 00:01:42,119
take off the last bit of data that was

40
00:01:42,119 --> 00:01:44,009
put on there's a little bit of

41
00:01:44,009 --> 00:01:46,950
terminology we always push items onto

42
00:01:46,950 --> 00:01:51,060
the stack and we pop items from the

43
00:01:51,060 --> 00:01:54,540
stack and the top of the stack is always

44
00:01:54,540 --> 00:01:56,939
the most recent item that was pushed

45
00:01:56,939 --> 00:01:59,369
onto it now because this is a video

46
00:01:59,369 --> 00:02:01,409
primarily about algorithms I'm not going

47
00:02:01,409 --> 00:02:02,880
to go into the implementation of the

48
00:02:02,880 --> 00:02:04,290
stack there are many ways to do it

49
00:02:04,290 --> 00:02:06,420
suffice it to say that if your system or

50
00:02:06,420 --> 00:02:08,758
your code uses a stack it will behave

51
00:02:08,758 --> 00:02:11,430
like this now the algorithm I'm going to

52
00:02:11,430 --> 00:02:12,930
talk about for developing a maze is

53
00:02:12,930 --> 00:02:13,560
known as the

54
00:02:13,560 --> 00:02:15,750
cursive back tracker I'm unsure of the

55
00:02:15,750 --> 00:02:17,340
origins of this algorithm but it has

56
00:02:17,340 --> 00:02:18,780
been around for a very long time

57
00:02:18,780 --> 00:02:21,300
and has some fantastic properties but

58
00:02:21,300 --> 00:02:22,530
whenever you want to write code that

59
00:02:22,530 --> 00:02:24,270
involves a more complex algorithm than

60
00:02:24,270 --> 00:02:25,860
normal it's always good to get the pen

61
00:02:25,860 --> 00:02:27,540
and paper out first make sure you

62
00:02:27,540 --> 00:02:29,640
understand it so I'm going to go through

63
00:02:29,640 --> 00:02:31,709
it by hand here on this very simple maze

64
00:02:31,709 --> 00:02:33,900
and it's four by four and along the top

65
00:02:33,900 --> 00:02:36,569
here along my x-axis I've got four cells

66
00:02:36,569 --> 00:02:39,150
0 1 2 3 and I've got my y-axis going

67
00:02:39,150 --> 00:02:42,300
down my plan is to fill this 4x4 array

68
00:02:42,300 --> 00:02:44,880
with maze and I'm going to start by

69
00:02:44,880 --> 00:02:47,130
arming my stack with some data and I'm

70
00:02:47,130 --> 00:02:48,390
going to armed it with the starting

71
00:02:48,390 --> 00:02:50,310
coordinate which in this case is going

72
00:02:50,310 --> 00:02:55,230
to be 0 0 so that's 0 along and 0 down

73
00:02:55,230 --> 00:02:57,569
I'm going to mark that cell as being

74
00:02:57,569 --> 00:02:59,549
visited so any cells that have a blue

75
00:02:59,549 --> 00:03:01,049
blob in the middle are going to be

76
00:03:01,049 --> 00:03:02,610
visited and I'm going to get a tick here

77
00:03:02,610 --> 00:03:04,590
and I'll know when to stop my algorithm

78
00:03:04,590 --> 00:03:06,780
because I should have visited all of the

79
00:03:06,780 --> 00:03:08,790
cells at the end and out therefore I'll

80
00:03:08,790 --> 00:03:11,010
have 16 ticks now I'm not going to make

81
00:03:11,010 --> 00:03:12,569
you sit through all of this I will speed

82
00:03:12,569 --> 00:03:13,920
up parts of it but it's a nice visual

83
00:03:13,920 --> 00:03:15,540
example of how the algorithm is put

84
00:03:15,540 --> 00:03:17,700
together don't forget that even though

85
00:03:17,700 --> 00:03:19,290
there's only one item in my stack the

86
00:03:19,290 --> 00:03:22,890
top of my stack is 0 0 and the algorithm

87
00:03:22,890 --> 00:03:25,500
goes like this from my current position

88
00:03:25,500 --> 00:03:27,720
which is the top of the stack I've got

89
00:03:27,720 --> 00:03:29,700
to choose one of my neighbors randomly

90
00:03:29,700 --> 00:03:32,850
so from position 0 0 here I've got a

91
00:03:32,850 --> 00:03:35,790
choice of this neighbor 1 0 or this

92
00:03:35,790 --> 00:03:38,850
neighbor 0 1 I roll the dice create a

93
00:03:38,850 --> 00:03:43,079
random number and I select 0 1 so I set

94
00:03:43,079 --> 00:03:45,660
that self to be visited and I create a

95
00:03:45,660 --> 00:03:50,970
link update my visited count and I've

96
00:03:50,970 --> 00:03:53,519
pushed the new location on to the top of

97
00:03:53,519 --> 00:03:57,450
my stack so now I repeat I look at my

98
00:03:57,450 --> 00:03:59,010
immediate neighbors and choose one of

99
00:03:59,010 --> 00:04:00,750
them at randomly that I've not already

100
00:04:00,750 --> 00:04:02,489
visited so my immediate neighbors

101
00:04:02,489 --> 00:04:07,620
consists of 0 0 1 1 and 0 2 well 0 0

102
00:04:07,620 --> 00:04:09,299
doesn't count because I've already

103
00:04:09,299 --> 00:04:11,700
visited it after rolling my dice I've

104
00:04:11,700 --> 00:04:16,079
decided that I'm going to move east and

105
00:04:16,079 --> 00:04:17,850
I create a link to it push the new cell

106
00:04:17,850 --> 00:04:20,608
onto the top of my stack that the cell

107
00:04:20,608 --> 00:04:22,140
is visited so one more time with

108
00:04:22,140 --> 00:04:24,539
commentary for completeness I take the

109
00:04:24,539 --> 00:04:27,120
top of my stack I choose a random

110
00:04:27,120 --> 00:04:28,740
direct neighbour so in this case I've

111
00:04:28,740 --> 00:04:36,990
got 1 0 2 1 0 1 and 1 2 I can't use this

112
00:04:36,990 --> 00:04:38,100
neighbor because I've already visited

113
00:04:38,100 --> 00:04:40,590
randomly choosing I'm going to go again

114
00:04:40,590 --> 00:04:44,880
to the east push the new coordinates to

115
00:04:44,880 --> 00:04:46,650
the top of my stack and update my

116
00:04:46,650 --> 00:04:49,210
visited count

117
00:04:49,210 --> 00:04:51,500
so now I've let the algorithm run for a

118
00:04:51,500 --> 00:04:53,240
few iterations and we've hit a problem I

119
00:04:53,240 --> 00:04:54,620
now need to choose a neighbor has not

120
00:04:54,620 --> 00:04:56,450
been visited before so my immediate

121
00:04:56,450 --> 00:05:02,060
neighbors are of course now 0 0 1 1 & 2

122
00:05:02,060 --> 00:05:05,060
0 however they've all been visited so I

123
00:05:05,060 --> 00:05:06,680
have no neighbors which haven't been

124
00:05:06,680 --> 00:05:09,200
visited I've now got to backtrack and

125
00:05:09,200 --> 00:05:10,820
this is where the stack became useful

126
00:05:10,820 --> 00:05:13,190
the stack contains a history of all the

127
00:05:13,190 --> 00:05:15,590
locations that I visited to the top of

128
00:05:15,590 --> 00:05:17,930
my stack is my current location and if I

129
00:05:17,930 --> 00:05:22,580
pop the top of the stack I can move back

130
00:05:22,580 --> 00:05:24,680
one but note I don't remove anything

131
00:05:24,680 --> 00:05:26,720
from the visited column and here I face

132
00:05:26,720 --> 00:05:28,700
the same situation all of my neighbors I

133
00:05:28,700 --> 00:05:30,530
visited before so I've got to move back

134
00:05:30,530 --> 00:05:32,920
one by popping off the top of the stack

135
00:05:32,920 --> 00:05:35,540
now I'm back at this location this is

136
00:05:35,540 --> 00:05:37,220
the first cell as we're backtracking

137
00:05:37,220 --> 00:05:39,110
that's got a neighbor that I can

138
00:05:39,110 --> 00:05:41,840
actually plot into which in this case is

139
00:05:41,840 --> 00:05:44,090
three to all of the other neighbors are

140
00:05:44,090 --> 00:05:45,470
not available they've already been

141
00:05:45,470 --> 00:05:47,210
visited so I've got little choice I've

142
00:05:47,210 --> 00:05:53,300
got to go here this is a new cell so it

143
00:05:53,300 --> 00:05:56,510
becomes visited and we pop the location

144
00:05:56,510 --> 00:05:58,670
onto the stack and now we'll let the

145
00:05:58,670 --> 00:06:01,720
algorithm continue again

146
00:06:05,540 --> 00:06:07,520
but now if it's a dead end again as we

147
00:06:07,520 --> 00:06:07,960
can see

148
00:06:07,960 --> 00:06:09,220
got no neighbors which I've not

149
00:06:09,220 --> 00:06:10,930
previously visited so I've got to

150
00:06:10,930 --> 00:06:13,990
backtrack and I do that by popping the

151
00:06:13,990 --> 00:06:16,479
top off the stack and using the top of

152
00:06:16,479 --> 00:06:20,310
the stack to set my current position

153
00:06:22,849 --> 00:06:24,830
and when I go to this location I do have

154
00:06:24,830 --> 00:06:26,659
one neighbor I have not already visited

155
00:06:26,659 --> 00:06:30,849
and it's the only one I can choose

156
00:06:37,740 --> 00:06:42,000
and so here I've now got sixteen ticks

157
00:06:42,000 --> 00:06:43,919
which is the number of cells that I've

158
00:06:43,919 --> 00:06:46,470
visited this algorithm is really nice

159
00:06:46,470 --> 00:06:48,720
because it guarantees completeness it

160
00:06:48,720 --> 00:06:50,789
doesn't matter how big my maze is it

161
00:06:50,789 --> 00:06:52,680
will fill all of the cell and it

162
00:06:52,680 --> 00:06:54,599
guarantees that every cell can touch

163
00:06:54,599 --> 00:06:56,160
every other cell so it doesn't matter

164
00:06:56,160 --> 00:06:57,599
where you start in the maze you're

165
00:06:57,599 --> 00:06:58,800
guaranteed to get to the objective

166
00:06:58,800 --> 00:07:01,199
location within the maze and like all

167
00:07:01,199 --> 00:07:02,970
perfect algorithms it's completely

168
00:07:02,970 --> 00:07:04,770
scalable not just in terms of dimensions

169
00:07:04,770 --> 00:07:06,569
of the maze but in how you apply it in

170
00:07:06,569 --> 00:07:08,789
this case I've got a single cell where I

171
00:07:08,789 --> 00:07:10,560
can visit my immediate neighbors north

172
00:07:10,560 --> 00:07:12,389
south east and west but it needn't be

173
00:07:12,389 --> 00:07:14,789
the case I could have many neighbors and

174
00:07:14,789 --> 00:07:16,470
apply the same algorithm and get a

175
00:07:16,470 --> 00:07:18,810
perfectly complete maze out of it once

176
00:07:18,810 --> 00:07:20,520
you've visited all the cells it's up to

177
00:07:20,520 --> 00:07:22,139
your rendering algorithm to then try and

178
00:07:22,139 --> 00:07:24,150
draw the maze so in this case I'm going

179
00:07:24,150 --> 00:07:26,639
to fill in wherever I haven't got a link

180
00:07:26,639 --> 00:07:28,380
between two cells so I'm going to draw a

181
00:07:28,380 --> 00:07:33,650
line here and here and here

182
00:07:37,120 --> 00:07:39,610
and once I filled in all the lines

183
00:07:39,610 --> 00:07:42,580
just develops the walls for my maze at

184
00:07:42,580 --> 00:07:44,409
which point we no longer need the stack

185
00:07:44,409 --> 00:07:45,789
and we can get rid of all of this

186
00:07:45,789 --> 00:07:54,759
construction data which leaves us with a

187
00:07:54,759 --> 00:07:56,740
really nice albeit rather small maze

188
00:07:56,740 --> 00:07:59,590
like structure now let's see how we will

189
00:07:59,590 --> 00:08:02,229
do this in code I'm going to start with

190
00:08:02,229 --> 00:08:04,629
a blank int main program as I always do

191
00:08:04,629 --> 00:08:06,819
and I'm going to pull in the one lone

192
00:08:06,819 --> 00:08:09,280
coda console game engine which you can

193
00:08:09,280 --> 00:08:10,750
see in the video marked in the little

194
00:08:10,750 --> 00:08:12,969
tab above now since this is the first

195
00:08:12,969 --> 00:08:14,529
video I've done that uses the technology

196
00:08:14,529 --> 00:08:16,000
I'm only going to go over it very

197
00:08:16,000 --> 00:08:17,229
briefly because you can look at that

198
00:08:17,229 --> 00:08:19,629
other video for the finer details but

199
00:08:19,629 --> 00:08:22,180
ultimately I need to derive a class from

200
00:08:22,180 --> 00:08:23,860
my console game engine which just

201
00:08:23,860 --> 00:08:25,689
handles all of the console stuff for me

202
00:08:25,689 --> 00:08:26,889
if you've seen my other videos you'll

203
00:08:26,889 --> 00:08:28,509
know that all of my programs involve

204
00:08:28,509 --> 00:08:30,400
creating a screen buffer and using get a

205
00:08:30,400 --> 00:08:32,289
sink key state to emulate some sort of

206
00:08:32,289 --> 00:08:34,360
game engine I've wrapped that up into a

207
00:08:34,360 --> 00:08:36,010
nice tidy package that I've called the

208
00:08:36,010 --> 00:08:37,839
one lone coda console game engine and

209
00:08:37,839 --> 00:08:40,240
there are two functions in this on user

210
00:08:40,240 --> 00:08:41,828
create which is where we do all of our

211
00:08:41,828 --> 00:08:43,659
definitions and creating of resources

212
00:08:43,659 --> 00:08:46,000
and on user update which is basically a

213
00:08:46,000 --> 00:08:48,070
per frame function so this is where we

214
00:08:48,070 --> 00:08:50,440
put all the fun stuff and implementing

215
00:08:50,440 --> 00:08:53,050
the class couldn't be simpler we just

216
00:08:53,050 --> 00:08:54,730
create the variable we construct the

217
00:08:54,730 --> 00:08:56,320
console to the dimensions that we want

218
00:08:56,320 --> 00:08:58,300
so in this case it's 160 characters

219
00:08:58,300 --> 00:09:00,760
across by 100 wide and each console

220
00:09:00,760 --> 00:09:03,029
character is going to be 8 by 8 pixels

221
00:09:03,029 --> 00:09:06,339
so then we call the start function this

222
00:09:06,339 --> 00:09:07,930
is only for Windows the construct

223
00:09:07,930 --> 00:09:09,670
console function calls things to the

224
00:09:09,670 --> 00:09:11,800
windows operating system that define how

225
00:09:11,800 --> 00:09:13,570
the console should look but you

226
00:09:13,570 --> 00:09:14,890
shouldn't let that put you off if you're

227
00:09:14,890 --> 00:09:17,199
a Linux or a Mac user the algorithm is

228
00:09:17,199 --> 00:09:18,970
still going to be platform independent

229
00:09:18,970 --> 00:09:21,579
now from my maze algorithm I know that

230
00:09:21,579 --> 00:09:23,320
it's fundamentally stack based so I'm

231
00:09:23,320 --> 00:09:24,730
going to include the stack from the

232
00:09:24,730 --> 00:09:26,949
standard library and in the game class

233
00:09:26,949 --> 00:09:28,779
I'm going to create some variables that

234
00:09:28,779 --> 00:09:32,260
define the maze specifically my maze has

235
00:09:32,260 --> 00:09:35,170
a width a height and I'm going to create

236
00:09:35,170 --> 00:09:37,420
an array here dynamically which stores a

237
00:09:37,420 --> 00:09:39,370
value for all the cells and I'm going to

238
00:09:39,370 --> 00:09:40,930
use this value to tell me which

239
00:09:40,930 --> 00:09:42,880
neighbors the cell is connected to and

240
00:09:42,880 --> 00:09:44,320
so to make this a little bit more

241
00:09:44,320 --> 00:09:46,060
readable I'm going to create an

242
00:09:46,060 --> 00:09:48,459
enumeration here where I'm defining some

243
00:09:48,459 --> 00:09:50,890
constants so for any given cell I can

244
00:09:50,890 --> 00:09:52,360
tell whether it's connected to its

245
00:09:52,360 --> 00:09:53,589
neighbors because

246
00:09:53,589 --> 00:09:55,720
the int value that represents that cell

247
00:09:55,720 --> 00:09:57,339
will contain the bits set in the

248
00:09:57,339 --> 00:09:59,259
appropriate locations and if I visited

249
00:09:59,259 --> 00:10:00,670
the cell as well I know that the

250
00:10:00,670 --> 00:10:02,740
algorithm also requires me to keep track

251
00:10:02,740 --> 00:10:04,209
of how many cells I've already visited

252
00:10:04,209 --> 00:10:06,670
and finally of course I'm going to need

253
00:10:06,670 --> 00:10:08,740
the stack and this might use something a

254
00:10:08,740 --> 00:10:10,240
bit new to the one-line code of videos

255
00:10:10,240 --> 00:10:13,750
I'm using the pair type pair allows you

256
00:10:13,750 --> 00:10:16,180
to store two things at the same time I

257
00:10:16,180 --> 00:10:18,639
could create a struct here myself that

258
00:10:18,639 --> 00:10:20,769
stores an x and a y-coordinate but I'm

259
00:10:20,769 --> 00:10:22,509
going to use the pair anyway why not

260
00:10:22,509 --> 00:10:25,029
this is new and so I have a stack that

261
00:10:25,029 --> 00:10:27,370
stores an object which I've typed pair

262
00:10:27,370 --> 00:10:30,220
but the pair is that templated to store

263
00:10:30,220 --> 00:10:32,949
two integers the first one will be the

264
00:10:32,949 --> 00:10:34,959
x-coordinate and the second one will be

265
00:10:34,959 --> 00:10:36,850
the y-coordinate now I'm ready to

266
00:10:36,850 --> 00:10:38,769
specify some parameters that define my

267
00:10:38,769 --> 00:10:40,449
maze so I'm going to set the width of

268
00:10:40,449 --> 00:10:43,240
the maze to 40 and the height to 25

269
00:10:43,240 --> 00:10:45,069
I've already predetermined that this

270
00:10:45,069 --> 00:10:46,899
dimension looks quite nice on the screen

271
00:10:46,899 --> 00:10:48,699
and because I might want to play with

272
00:10:48,699 --> 00:10:50,050
these numbers later I'm going to

273
00:10:50,050 --> 00:10:51,639
allocate the maze memory dynamically

274
00:10:51,639 --> 00:10:53,889
based on the dimensions we've just set

275
00:10:53,889 --> 00:10:56,350
it's also quite important that we set

276
00:10:56,350 --> 00:10:58,600
all of the elements in the maze array to

277
00:10:58,600 --> 00:11:02,019
0 to begin with I'm using the mem set

278
00:11:02,019 --> 00:11:04,180
command for this and now I need to

279
00:11:04,180 --> 00:11:05,980
specify the staffing conditions for my

280
00:11:05,980 --> 00:11:11,709
maze the stack has to have something in

281
00:11:11,709 --> 00:11:13,360
it to begin with so I'm going to push on

282
00:11:13,360 --> 00:11:15,189
to that a new pair and I'm going to

283
00:11:15,189 --> 00:11:17,529
usually make pair function and we're

284
00:11:17,529 --> 00:11:19,269
going to start like I did when I was

285
00:11:19,269 --> 00:11:21,310
drawing it by hand in the top left hand

286
00:11:21,310 --> 00:11:23,649
corner which means I also have to set

287
00:11:23,649 --> 00:11:25,750
that cell to be visited and conveniently

288
00:11:25,750 --> 00:11:28,089
the top left corner of my maze array

289
00:11:28,089 --> 00:11:34,029
also happens have the index 0 I'm going

290
00:11:34,029 --> 00:11:35,709
to use one of the bits that I set before

291
00:11:35,709 --> 00:11:37,930
and because I've already visited one

292
00:11:37,930 --> 00:11:40,059
cell I'm going to set my visited cell

293
00:11:40,059 --> 00:11:47,050
count to 1 as you can see there's very

294
00:11:47,050 --> 00:11:48,579
little required to initialize this

295
00:11:48,579 --> 00:11:51,660
algorithm but it's important that you do

296
00:11:51,660 --> 00:11:53,500
before we get stuck in with the

297
00:11:53,500 --> 00:11:54,879
algorithm I think it's quite important

298
00:11:54,879 --> 00:11:56,199
that we have a way to visualize it that

299
00:11:56,199 --> 00:11:57,759
way we know if we're coding it in the

300
00:11:57,759 --> 00:12:00,279
right direction so to begin with on the

301
00:12:00,279 --> 00:12:02,170
on user update function I'm going to

302
00:12:02,170 --> 00:12:03,730
clear the screen and that involves

303
00:12:03,730 --> 00:12:05,649
basically drawing a space to my console

304
00:12:05,649 --> 00:12:07,270
in all locations

305
00:12:07,270 --> 00:12:09,610
screen width and screen height from the

306
00:12:09,610 --> 00:12:11,920
top left corner and as discussed

307
00:12:11,920 --> 00:12:14,020
previously my maze consists of a 2d

308
00:12:14,020 --> 00:12:16,630
array of cells so I'm going to iterate

309
00:12:16,630 --> 00:12:18,760
through each of the cells mates with and

310
00:12:18,760 --> 00:12:21,010
mate height and for each cell in the

311
00:12:21,010 --> 00:12:22,570
array I'm going to check does the

312
00:12:22,570 --> 00:12:24,820
integer have the cell visited bit set in

313
00:12:24,820 --> 00:12:26,950
which case if it does we draw a white

314
00:12:26,950 --> 00:12:29,530
pixel or a white block character to that

315
00:12:29,530 --> 00:12:31,600
location on the console or we draw a

316
00:12:31,600 --> 00:12:33,730
blue one so let's just have a quick look

317
00:12:33,730 --> 00:12:37,630
what that looks like well it's a blue

318
00:12:37,630 --> 00:12:39,730
rectangle with a tiny little white dot

319
00:12:39,730 --> 00:12:41,170
so that's good I mean that indicates

320
00:12:41,170 --> 00:12:44,140
that our maze of the dimensions 40 by 25

321
00:12:44,140 --> 00:12:46,900
does have 40 blue characters by 25 blue

322
00:12:46,900 --> 00:12:48,310
characters and the one cell we've

323
00:12:48,310 --> 00:12:50,020
already set to visited in the top left

324
00:12:50,020 --> 00:12:52,150
has been set however everything looks a

325
00:12:52,150 --> 00:12:54,760
bit small and there's a problem we don't

326
00:12:54,760 --> 00:12:57,130
have anywhere to draw the walls I'm

327
00:12:57,130 --> 00:12:58,750
going to introduce the notion of a path

328
00:12:58,750 --> 00:13:00,970
width which will specify how many

329
00:13:00,970 --> 00:13:03,010
on-screen console character cells

330
00:13:03,010 --> 00:13:05,680
represent a single cell in my maze so

331
00:13:05,680 --> 00:13:07,630
for example if the width is set to 2 i

332
00:13:07,630 --> 00:13:11,320
actually occupy a 2 by 2 block of cells

333
00:13:11,320 --> 00:13:15,250
on the console which represents one cell

334
00:13:15,250 --> 00:13:18,040
in my maze then i can surround the two

335
00:13:18,040 --> 00:13:21,180
sides to the east and the south of that

336
00:13:21,180 --> 00:13:26,970
one cell with blocks that represent wall

337
00:13:26,970 --> 00:13:31,600
so here's my 2 by 2 cell and here is a 2

338
00:13:31,600 --> 00:13:36,220
by 2 cell and here is a 2 by 2 cell and

339
00:13:36,220 --> 00:13:38,460
we've now got positioned to add walls I

340
00:13:38,460 --> 00:13:40,990
only need to concern myself with walls

341
00:13:40,990 --> 00:13:44,220
at the east and south side of the cells

342
00:13:44,220 --> 00:13:48,580
because if two cells are linked then

343
00:13:48,580 --> 00:13:51,660
this cell loses its western wall and

344
00:13:51,660 --> 00:13:56,100
this cell loses Eastern wall

345
00:13:56,370 --> 00:13:59,620
ie the wall is shared between them and

346
00:13:59,620 --> 00:14:01,630
of course the same applies for north and

347
00:14:01,630 --> 00:14:03,870
south

348
00:14:11,280 --> 00:14:15,270
so this is now cell position zero zero

349
00:14:15,270 --> 00:14:18,240
and this would become cell one zero and

350
00:14:18,240 --> 00:14:21,450
this one would be 0 1 and 1 1

351
00:14:21,450 --> 00:14:23,190
but the relationship to the console

352
00:14:23,190 --> 00:14:25,380
characters underneath is now the cell

353
00:14:25,380 --> 00:14:31,230
coordinate times 2 to get us to here and

354
00:14:31,230 --> 00:14:33,690
we always plus 1 to give us some wall at

355
00:14:33,690 --> 00:14:35,850
the end and of course that happens in

356
00:14:35,850 --> 00:14:42,300
both axis so we can consider then a

357
00:14:42,300 --> 00:14:47,460
whole complete cell with walls and exits

358
00:14:47,460 --> 00:14:49,980
and everything else is a multiple of

359
00:14:49,980 --> 00:14:52,770
path width plus 1 let's add another

360
00:14:52,770 --> 00:14:55,890
variable to our class path width and

361
00:14:55,890 --> 00:14:59,430
we'll define this as being 3 so our May

362
00:14:59,430 --> 00:15:01,320
cell will represent 3 console characters

363
00:15:01,320 --> 00:15:04,140
across and one for the wall we then need

364
00:15:04,140 --> 00:15:05,820
to modify our drawing algorithm to

365
00:15:05,820 --> 00:15:08,100
accept this change in scale so every

366
00:15:08,100 --> 00:15:15,620
position becomes x path width plus 1

367
00:15:15,620 --> 00:15:20,010
let's take a look well we can now see

368
00:15:20,010 --> 00:15:21,240
that it's spread out across the whole

369
00:15:21,240 --> 00:15:22,860
console which is good but it's not

370
00:15:22,860 --> 00:15:24,750
filled in the individual cells which is

371
00:15:24,750 --> 00:15:27,600
bad therefore I need an additional loop

372
00:15:27,600 --> 00:15:30,450
inside my maze loop here let's draws in

373
00:15:30,450 --> 00:15:34,440
each cell so for each cell in my maze

374
00:15:34,440 --> 00:15:37,020
I'm now going to go through each cell in

375
00:15:37,020 --> 00:15:42,330
the console for the path width and we

376
00:15:42,330 --> 00:15:45,589
just have to add this onto the end

377
00:15:48,339 --> 00:15:52,429
take a look excellent

378
00:15:52,429 --> 00:15:55,369
we now have cells which are 3x3 with a

379
00:15:55,369 --> 00:15:59,660
wall of 1 on our console great we're

380
00:15:59,660 --> 00:16:01,459
also in tourney to draw in our pathways

381
00:16:01,459 --> 00:16:03,559
to overwrite the wall so we can show the

382
00:16:03,559 --> 00:16:05,299
cells are connected so if any of our

383
00:16:05,299 --> 00:16:07,879
cells have the path to East or path to

384
00:16:07,879 --> 00:16:10,249
South set we also want to draw those in

385
00:16:10,249 --> 00:16:13,189
as well and because our walls are always

386
00:16:13,189 --> 00:16:14,809
only one character thick I don't need to

387
00:16:14,809 --> 00:16:16,879
do a two-dimensional plot this time and

388
00:16:16,879 --> 00:16:18,319
get away with a single dimensional one

389
00:16:18,319 --> 00:16:19,610
so I'm just going to go through the path

390
00:16:19,610 --> 00:16:22,009
width one at a time and the first thing

391
00:16:22,009 --> 00:16:23,749
I want to do is check well does the cell

392
00:16:23,749 --> 00:16:25,989
in this case does it have a self path

393
00:16:25,989 --> 00:16:28,579
and if it does I want to draw in the

394
00:16:28,579 --> 00:16:31,069
cells to give us that passageway from

395
00:16:31,069 --> 00:16:33,980
the north cell to the South cell or from

396
00:16:33,980 --> 00:16:35,839
the South cell to the North cell who

397
00:16:35,839 --> 00:16:38,239
knows and we'll do the same for east to

398
00:16:38,239 --> 00:16:40,999
west so if the cell has a passage from

399
00:16:40,999 --> 00:16:43,339
the east to the West in either direction

400
00:16:43,339 --> 00:16:46,129
we want to overwrite the wall the black

401
00:16:46,129 --> 00:16:47,929
cells in the background on the console

402
00:16:47,929 --> 00:16:50,209
we want to draw them in with path color

403
00:16:50,209 --> 00:16:52,759
which is white now we've got a way to

404
00:16:52,759 --> 00:16:54,470
visualize the maze let's get stuck into

405
00:16:54,470 --> 00:16:55,670
the really fun stuff let's actually

406
00:16:55,670 --> 00:16:58,069
create it the maze creation can also go

407
00:16:58,069 --> 00:17:00,350
in the on user update function and we

408
00:17:00,350 --> 00:17:02,389
want to create maze only if the number

409
00:17:02,389 --> 00:17:04,789
of visited cells is less than the width

410
00:17:04,789 --> 00:17:07,429
times the height ie we can only do more

411
00:17:07,429 --> 00:17:09,199
maze development if there are any cells

412
00:17:09,199 --> 00:17:14,659
that we haven't visited step one is to

413
00:17:14,659 --> 00:17:20,559
create a set of the unvisited neighbors

414
00:17:21,130 --> 00:17:25,870
let's consider the North neighbor first

415
00:17:26,770 --> 00:17:29,600
as we're working with 2d arrays we don't

416
00:17:29,600 --> 00:17:31,130
want to go out of bounds and cause all

417
00:17:31,130 --> 00:17:33,770
sorts of memory errors so it's important

418
00:17:33,770 --> 00:17:35,270
that we don't check for neighbors that

419
00:17:35,270 --> 00:17:37,100
the relative bounds of our maze and if

420
00:17:37,100 --> 00:17:38,360
we're checking for northern neighbors

421
00:17:38,360 --> 00:17:39,919
that means we shouldn't be checking for

422
00:17:39,919 --> 00:17:42,440
any if we're currently on the top row of

423
00:17:42,440 --> 00:17:44,179
our mates because they just don't exist

424
00:17:44,179 --> 00:17:45,470
there aren't any northern neighbors so

425
00:17:45,470 --> 00:17:46,490
that's the first thing I'm going to

426
00:17:46,490 --> 00:17:48,139
check for and to do that I'm going to

427
00:17:48,139 --> 00:17:50,149
take our stack and I'm going to look at

428
00:17:50,149 --> 00:17:51,470
the element that's at the top of the

429
00:17:51,470 --> 00:17:53,600
stack using the top function and I'm

430
00:17:53,600 --> 00:17:54,830
going to check because the stack

431
00:17:54,830 --> 00:17:56,809
contains pairs I'm going to check the

432
00:17:56,809 --> 00:17:58,940
second element of that pair which if you

433
00:17:58,940 --> 00:18:00,679
remember is our y coordinate and I'm

434
00:18:00,679 --> 00:18:01,880
going to ensure that it's great

435
00:18:01,880 --> 00:18:04,309
than zero now we're trying to develop a

436
00:18:04,309 --> 00:18:05,840
list of all the neighbors that haven't

437
00:18:05,840 --> 00:18:07,880
been visited so we need to check that in

438
00:18:07,880 --> 00:18:12,110
our maze array and to do this we need to

439
00:18:12,110 --> 00:18:14,330
get the index now we're currently using

440
00:18:14,330 --> 00:18:16,340
the stack and it's using a pair of

441
00:18:16,340 --> 00:18:18,919
second and first for Y and X and so that

442
00:18:18,919 --> 00:18:20,809
looks something like this which you can

443
00:18:20,809 --> 00:18:26,299
see is a bit of a mouthful and we want

444
00:18:26,299 --> 00:18:28,580
to see how's the cell visited flag bit

445
00:18:28,580 --> 00:18:31,910
bin set which will do by checking if

446
00:18:31,910 --> 00:18:34,909
it's equal to one but this isn't very

447
00:18:34,909 --> 00:18:36,559
useful to us at all in fact very

448
00:18:36,559 --> 00:18:39,200
difficult to read and the y coordinate

449
00:18:39,200 --> 00:18:40,580
in this case would get replaced with

450
00:18:40,580 --> 00:18:42,559
minus one because we're checking for the

451
00:18:42,559 --> 00:18:46,100
neighbor above us in our y axis and the

452
00:18:46,100 --> 00:18:48,470
x coordinate gets set to zero because

453
00:18:48,470 --> 00:18:50,240
we're checking in just in vertically

454
00:18:50,240 --> 00:18:51,470
we're not bothered about the east to

455
00:18:51,470 --> 00:18:55,490
west so in the event of us being in a

456
00:18:55,490 --> 00:18:58,100
valid location in the array and that our

457
00:18:58,100 --> 00:19:00,679
neighbor to the north of us exists and

458
00:19:00,679 --> 00:19:02,480
haven't been visited we want to store

459
00:19:02,480 --> 00:19:04,130
this and I'm going to do this by

460
00:19:04,130 --> 00:19:09,110
creating a vector with the vector I'm

461
00:19:09,110 --> 00:19:10,940
going to push to it and identify and in

462
00:19:10,940 --> 00:19:12,799
this case I'm going to use zero that

463
00:19:12,799 --> 00:19:15,100
will say that my northern neighbor

464
00:19:15,100 --> 00:19:18,710
exists and is unvisited and I can use

465
00:19:18,710 --> 00:19:21,140
similar code to check for my eastern

466
00:19:21,140 --> 00:19:23,840
neighbor which in this case I'm going to

467
00:19:23,840 --> 00:19:26,000
use one as the identifier but here I

468
00:19:26,000 --> 00:19:28,039
don't want to check for minus one I want

469
00:19:28,039 --> 00:19:31,400
to check for zero in the y axis and plus

470
00:19:31,400 --> 00:19:33,470
one in the AL are you know what this is

471
00:19:33,470 --> 00:19:35,630
actually getting too much I've just

472
00:19:35,630 --> 00:19:36,919
gotten to the point where I can barely

473
00:19:36,919 --> 00:19:38,900
understand my own code so I'm going to

474
00:19:38,900 --> 00:19:40,460
create a little lambda function to help

475
00:19:40,460 --> 00:19:45,230
me out the lambda function is going to

476
00:19:45,230 --> 00:19:51,500
take an X and a y-coordinate and do this

477
00:19:51,500 --> 00:19:55,270
horrible little bit of offsetting for me

478
00:19:59,130 --> 00:20:05,799
let's change that to an X and change

479
00:20:05,799 --> 00:20:11,350
that to a Y and semicolon and get rid of

480
00:20:11,350 --> 00:20:12,789
this now and just call my lambda

481
00:20:12,789 --> 00:20:17,320
function so if I'm checking in the

482
00:20:17,320 --> 00:20:18,700
northern direction I know I'm not

483
00:20:18,700 --> 00:20:20,470
bothered about X but I'm looking at

484
00:20:20,470 --> 00:20:26,260
minus 1 in the Y that's much much tidier

485
00:20:26,260 --> 00:20:27,970
and I can also do the same for my

486
00:20:27,970 --> 00:20:29,260
Eastern function which in this case I'm

487
00:20:29,260 --> 00:20:31,419
looking along the x-axis by 1 but I'm

488
00:20:31,419 --> 00:20:33,850
not looking in the y-axis at all now you

489
00:20:33,850 --> 00:20:35,530
might be thinking why don't I just do

490
00:20:35,530 --> 00:20:37,600
this with a macro well of course you

491
00:20:37,600 --> 00:20:39,730
could do this with a macro but the

492
00:20:39,730 --> 00:20:41,440
language now provides the auto feature

493
00:20:41,440 --> 00:20:43,390
quite like this I like the lambda

494
00:20:43,390 --> 00:20:44,890
function approach to doing this it means

495
00:20:44,890 --> 00:20:46,929
I'm forced to put the code where it's

496
00:20:46,929 --> 00:20:49,360
needed macros can be any word and a

497
00:20:49,360 --> 00:20:51,400
little bit unregulated they can get a

498
00:20:51,400 --> 00:20:53,320
bit dangerous and fiddly will also

499
00:20:53,320 --> 00:20:55,539
exploit the fact that the if statement

500
00:20:55,539 --> 00:20:57,220
is checked in order so we can get rid of

501
00:20:57,220 --> 00:21:00,010
this secondary call to if which makes

502
00:21:00,010 --> 00:21:02,140
that line of code much more concise now

503
00:21:02,140 --> 00:21:03,940
I'm going to repeat that for the other

504
00:21:03,940 --> 00:21:06,429
directions and here we can see I've got

505
00:21:06,429 --> 00:21:09,280
now an ID of zero for north one for East

506
00:21:09,280 --> 00:21:12,159
two for self and three for West you'll

507
00:21:12,159 --> 00:21:13,780
notice with the east and west neighbors

508
00:21:13,780 --> 00:21:16,659
I'm not using the y component of the

509
00:21:16,659 --> 00:21:18,610
vector to check whether I'm in bounds or

510
00:21:18,610 --> 00:21:20,470
not I'm using the X which is the first

511
00:21:20,470 --> 00:21:22,809
of the pair I've just flagged a little

512
00:21:22,809 --> 00:21:24,220
error here I'm not actually checking if

513
00:21:24,220 --> 00:21:26,080
the cell is visited of course I am

514
00:21:26,080 --> 00:21:28,360
checking if the cell is not visited so I

515
00:21:28,360 --> 00:21:29,890
want to make sure that that is a zero

516
00:21:29,890 --> 00:21:33,760
and not a one my apologies so now I have

517
00:21:33,760 --> 00:21:35,919
a vector that contains only valid

518
00:21:35,919 --> 00:21:38,110
neighbors that I can visit which I might

519
00:21:38,110 --> 00:21:39,549
not have any at all so I need to check

520
00:21:39,549 --> 00:21:42,220
for that if I don't have any then I'm

521
00:21:42,220 --> 00:21:44,409
going to be popping off the stack if you

522
00:21:44,409 --> 00:21:47,380
remember the algorithm before but let's

523
00:21:47,380 --> 00:21:48,850
for now assume that I do have some

524
00:21:48,850 --> 00:21:50,710
neighbors and the nice thing about

525
00:21:50,710 --> 00:21:52,450
bundling things into a vector this way

526
00:21:52,450 --> 00:21:54,820
is it makes other operations easier so I

527
00:21:54,820 --> 00:21:56,740
want to choose a neighbor at random well

528
00:21:56,740 --> 00:21:58,450
to do this all I need to do is randomly

529
00:21:58,450 --> 00:22:00,490
choose a number from the neighbors size

530
00:22:00,490 --> 00:22:03,070
and use that as the index so I can get

531
00:22:03,070 --> 00:22:04,900
something that tells me what direction

532
00:22:04,900 --> 00:22:07,390
is my neighbor now and because I've been

533
00:22:07,390 --> 00:22:09,549
pushing zero one two and three I know

534
00:22:09,549 --> 00:22:11,049
from this identify

535
00:22:11,049 --> 00:22:13,059
which way to go next so that's the value

536
00:22:13,059 --> 00:22:14,950
that gets stored into the next cell

537
00:22:14,950 --> 00:22:17,499
Direction variable the algorithm says

538
00:22:17,499 --> 00:22:19,299
that once I've chosen a neighbor I then

539
00:22:19,299 --> 00:22:20,710
need to create a path between the

540
00:22:20,710 --> 00:22:22,179
neighbor and the cell that I'm currently

541
00:22:22,179 --> 00:22:24,669
in well now that they know both of those

542
00:22:24,669 --> 00:22:26,350
cells I'm just going to use a little

543
00:22:26,350 --> 00:22:28,989
switch block here and fill in the blanks

544
00:22:28,989 --> 00:22:32,019
so let's assume the neighbor is north I

545
00:22:32,019 --> 00:22:34,989
want to create a path to the north so my

546
00:22:34,989 --> 00:22:37,509
current cell which is locally

547
00:22:37,509 --> 00:22:39,879
represented by 0 0 here because remember

548
00:22:39,879 --> 00:22:43,480
this lambda function uses the stack to

549
00:22:43,480 --> 00:22:44,950
work out where they say it always used

550
00:22:44,950 --> 00:22:46,450
at the top of the stack and all of the

551
00:22:46,450 --> 00:22:48,940
coordinates are relative to the location

552
00:22:48,940 --> 00:22:50,649
at the top of the stack so if there's a

553
00:22:50,649 --> 00:22:52,690
path to the north I'm going to or it

554
00:22:52,690 --> 00:22:55,029
with the path to the North bit whilst

555
00:22:55,029 --> 00:22:56,710
I'm here I may as well tell the cell

556
00:22:56,710 --> 00:22:58,600
that's above me ie my northern neighbor

557
00:22:58,600 --> 00:23:01,059
that the one below it has a path to the

558
00:23:01,059 --> 00:23:03,249
south and then going to push to the top

559
00:23:03,249 --> 00:23:06,489
of my stack the northern neighbors

560
00:23:06,489 --> 00:23:10,690
coordinates so as I push to the stack I

561
00:23:10,690 --> 00:23:13,570
create a new pair the x coordinate is

562
00:23:13,570 --> 00:23:16,090
the current top of the stacks x

563
00:23:16,090 --> 00:23:19,389
coordinate plus 0 and the y coordinate

564
00:23:19,389 --> 00:23:21,639
is the current top of the stacks second

565
00:23:21,639 --> 00:23:24,190
part minus 1 so this is the y coordinate

566
00:23:24,190 --> 00:23:26,769
minus 1 to the northern neighbor if any

567
00:23:26,769 --> 00:23:29,049
of this switch block executes it assumes

568
00:23:29,049 --> 00:23:31,840
that I have now entered that new cell so

569
00:23:31,840 --> 00:23:33,999
I need to increase my visited cell count

570
00:23:33,999 --> 00:23:39,249
and I also need to make the cell that I

571
00:23:39,249 --> 00:23:40,570
am currently in so the one that's now

572
00:23:40,570 --> 00:23:42,100
the top of the stack which is the new

573
00:23:42,100 --> 00:23:46,090
cell which I can index with 0 0 now I

574
00:23:46,090 --> 00:23:48,100
need to tell that cell that I have been

575
00:23:48,100 --> 00:23:56,470
visited so I'll just put in new cell

576
00:23:56,470 --> 00:23:59,619
here is a bit of a reminder let's

577
00:23:59,619 --> 00:24:01,720
duplicate this code for the other

578
00:24:01,720 --> 00:24:05,679
options so for South instead of checking

579
00:24:05,679 --> 00:24:09,009
for -1 we're now checking for +1 and of

580
00:24:09,009 --> 00:24:10,899
course the southern neighbor we set the

581
00:24:10,899 --> 00:24:12,759
northern path and we set our current

582
00:24:12,759 --> 00:24:18,600
path to self let's not also forget

583
00:24:19,220 --> 00:24:22,700
the coordinates of the new cell so all

584
00:24:22,700 --> 00:24:24,830
of this was on the condition that we had

585
00:24:24,830 --> 00:24:26,860
some neighbors that we hadn't visited

586
00:24:26,860 --> 00:24:28,880
what if we didn't have any neighbors

587
00:24:28,880 --> 00:24:30,380
well if you remember from the algorithm

588
00:24:30,380 --> 00:24:33,950
before we need to backtrack and because

589
00:24:33,950 --> 00:24:36,230
we're using a stack that's really really

590
00:24:36,230 --> 00:24:45,290
complicated done so let's take a look

591
00:24:45,290 --> 00:24:50,180
and see what happens well I think that's

592
00:24:50,180 --> 00:24:51,920
fantastic we've got a really large and

593
00:24:51,920 --> 00:24:54,710
complex maze and labyrinth okay it's

594
00:24:54,710 --> 00:24:57,320
really nice I'm going to slow down the

595
00:24:57,320 --> 00:24:59,510
algorithm by adding an artificial delay

596
00:24:59,510 --> 00:25:00,830
remember this is just for visualization

597
00:25:00,830 --> 00:25:02,900
it's not that important that we're

598
00:25:02,900 --> 00:25:04,640
breaking some rules here so I'm going to

599
00:25:04,640 --> 00:25:06,590
use the sleep floor function to delay

600
00:25:06,590 --> 00:25:08,330
for 10 milliseconds in each of our on

601
00:25:08,330 --> 00:25:10,460
user update calls this means we'll have

602
00:25:10,460 --> 00:25:13,280
a maximum of 100 cell updates per second

603
00:25:13,280 --> 00:25:15,230
ie were limiting programs through at

604
00:25:15,230 --> 00:25:17,900
about 100 frames per second let's have a

605
00:25:17,900 --> 00:25:22,520
look the algorithm is really pleasant to

606
00:25:22,520 --> 00:25:24,500
watch we can see the choice to draw the

607
00:25:24,500 --> 00:25:26,420
longest path that it possibly can until

608
00:25:26,420 --> 00:25:28,550
it boxes itself in and then it back

609
00:25:28,550 --> 00:25:30,920
tracks to illustrate this I've also got

610
00:25:30,920 --> 00:25:32,690
it to draw the top of the stack with a

611
00:25:32,690 --> 00:25:35,170
green rectangle

612
00:25:50,260 --> 00:25:52,840
in many respects this is similar to a

613
00:25:52,840 --> 00:25:54,520
flood fill algorithm and will probably

614
00:25:54,520 --> 00:25:55,990
definitely have a look at those in the

615
00:25:55,990 --> 00:25:57,910
future and so there you have it the

616
00:25:57,910 --> 00:25:59,530
quick look at a very simple maze

617
00:25:59,530 --> 00:26:01,270
generation algorithm there are many

618
00:26:01,270 --> 00:26:03,250
other algorithms for generating mazes

619
00:26:03,250 --> 00:26:04,660
particularly if you want mazes with a

620
00:26:04,660 --> 00:26:07,480
set of properties such as long corridors

621
00:26:07,480 --> 00:26:09,700
or extra rooms but you can always use

622
00:26:09,700 --> 00:26:11,470
this one as a starting point for example

623
00:26:11,470 --> 00:26:13,900
you could proceed some of the cells as

624
00:26:13,900 --> 00:26:15,760
being already visited now I appreciate

625
00:26:15,760 --> 00:26:17,770
that this video hasn't been as simple as

626
00:26:17,770 --> 00:26:19,570
some of my others and this is going to

627
00:26:19,570 --> 00:26:21,850
happen from time to time sometimes the

628
00:26:21,850 --> 00:26:24,130
topics are quite complicated and need me

629
00:26:24,130 --> 00:26:25,900
to use more advanced coding techniques

630
00:26:25,900 --> 00:26:27,220
than perhaps you see in some of my other

631
00:26:27,220 --> 00:26:29,770
videos and I'm still not sure yet about

632
00:26:29,770 --> 00:26:31,240
using something like the one learned

633
00:26:31,240 --> 00:26:33,790
coder games console engine in the

634
00:26:33,790 --> 00:26:35,380
background I don't know if it does

635
00:26:35,380 --> 00:26:37,179
actually accelerate the development of

636
00:26:37,179 --> 00:26:39,220
the code or the video but I've got some

637
00:26:39,220 --> 00:26:41,049
other ideas for it for other projects

638
00:26:41,049 --> 00:26:42,309
which require things to be a bit more

639
00:26:42,309 --> 00:26:43,929
graphical and I'm trying to avoid

640
00:26:43,929 --> 00:26:45,750
needing to develop a Windows application

641
00:26:45,750 --> 00:26:48,549
anyway as usual the codes going to be

642
00:26:48,549 --> 00:26:50,380
available on github you can download it

643
00:26:50,380 --> 00:26:52,900
hack it generate some mazes for me if

644
00:26:52,900 --> 00:26:54,669
you've enjoyed this give it a thumbs up

645
00:26:54,669 --> 00:26:55,960
it does great wonders for my self-esteem

646
00:26:55,960 --> 00:26:58,900
and please think about subscribing lots

647
00:26:58,900 --> 00:27:00,460
of people have been subscribing recently

648
00:27:00,460 --> 00:27:01,870
and I'm really grateful for some of the

649
00:27:01,870 --> 00:27:03,640
fantastic comments that people have been

650
00:27:03,640 --> 00:27:05,860
leaving so please keep all that up and

651
00:27:05,860 --> 00:27:09,240
I'll see you next time take care

